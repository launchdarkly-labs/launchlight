import { describe, it, expect, beforeEach, vi } from 'vitest';
import { init, getAnonymousId, resetAnonymousId } from './index.js';
import type { InjectorConfig } from './index.js';

// Mock LaunchDarkly SDK
vi.mock('launchdarkly-js-client-sdk', () => ({
  initialize: vi.fn(() => ({
    waitForInitialization: vi.fn(() => Promise.resolve()),
    variation: vi.fn(() => ({ version: 1, ops: [] })),
    track: vi.fn(),
    close: vi.fn(),
    on: vi.fn(),
    off: vi.fn()
  }))
}));

// Mock the auto-ID module
vi.mock('./auto-id.js', () => ({
  initializeAutoId: vi.fn(() => ({
    getOrCreateId: vi.fn()
  })),
  getAnonymousId: vi.fn(),
  resetAnonymousId: vi.fn(),
  getAutoIdDiagnostics: vi.fn(() => ({
    cookiesAvailable: true,
    localStorageAvailable: true,
    doNotTrack: false,
    secureContext: true,
    currentId: null,
    storageMethod: 'none'
  }))
}));

// Mock patch engine
vi.mock('@webexp/patch-engine', () => ({
  applyPayload: vi.fn(() => ({ success: true, results: [], errors: [] })),
  enableSpaMode: vi.fn(),
  cleanupPatchEngine: vi.fn()
}));

import { initializeAutoId } from './auto-id.js';
import * as LD from 'launchdarkly-js-client-sdk';

describe('Injector Auto-ID Integration', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('init with auto-ID enabled', () => {
    it('should use auto-generated ID when no context key provided', async () => {
      const mockAutoIdManager = {
        getOrCreateId: vi.fn().mockResolvedValue('webexp_autogenerated123456')
      };
      
      (initializeAutoId as any).mockReturnValue(mockAutoIdManager);
      
      const config: InjectorConfig = {
        envKey: 'test-env',
        flagKey: 'test-flag',
        autoId: { enabled: true }
      };
      
      const injector = await init(config);
      
      expect(initializeAutoId).toHaveBeenCalledWith({ enabled: true });
      expect(mockAutoIdManager.getOrCreateId).toHaveBeenCalled();
      expect(LD.initialize).toHaveBeenCalledWith(
        'test-env',
        {
          kind: 'user',
          key: 'webexp_autogenerated123456',
          anonymous: true
        },
        expect.any(Object)
      );
      expect(injector).toBeDefined();
    });

    it('should preserve existing context properties with auto-generated key', async () => {
      const mockAutoIdManager = {
        getOrCreateId: vi.fn().mockResolvedValue('webexp_autogenerated123456')
      };
      
      (initializeAutoId as any).mockReturnValue(mockAutoIdManager);
      
      const config: InjectorConfig = {
        envKey: 'test-env',
        flagKey: 'test-flag',
        context: {
          kind: 'user',
          custom: {
            plan: 'premium'
          }
        },
        autoId: { enabled: true }
      };
      
      await init(config);
      
      expect(LD.initialize).toHaveBeenCalledWith(
        'test-env',
        {
          kind: 'user',
          key: 'webexp_autogenerated123456',
          anonymous: true,
          custom: {
            plan: 'premium'
          }
        },
        expect.any(Object)
      );
    });

    it('should not use auto-ID when explicit context key provided', async () => {
      const mockAutoIdManager = {
        getOrCreateId: vi.fn().mockResolvedValue('webexp_autogenerated123456')
      };
      
      (initializeAutoId as any).mockReturnValue(mockAutoIdManager);
      
      const config: InjectorConfig = {
        envKey: 'test-env',
        flagKey: 'test-flag',
        context: {
          kind: 'user',
          key: 'explicit-user-123'
        },
        autoId: { enabled: true }
      };
      
      await init(config);
      
      expect(initializeAutoId).toHaveBeenCalledWith({ enabled: true });
      expect(mockAutoIdManager.getOrCreateId).toHaveBeenCalled();
      
      // Should use the explicit key, not the auto-generated one
      expect(LD.initialize).toHaveBeenCalledWith(
        'test-env',
        {
          kind: 'user',
          key: 'explicit-user-123'
        },
        expect.any(Object)
      );
    });

    it('should handle auto-ID generation failure gracefully', async () => {
      const mockAutoIdManager = {
        getOrCreateId: vi.fn().mockResolvedValue(null)
      };
      
      (initializeAutoId as any).mockReturnValue(mockAutoIdManager);
      
      const config: InjectorConfig = {
        envKey: 'test-env',
        flagKey: 'test-flag',
        autoId: { enabled: true }
      };
      
      await init(config);
      
      // Should fall back to default anonymous context
      expect(LD.initialize).toHaveBeenCalledWith(
        'test-env',
        undefined,
        expect.any(Object)
      );
    });

    it('should pass through auto-ID options correctly', async () => {
      const autoIdOptions = {
        enabled: true,
        cookieName: 'custom_webexp_id',
        ttlDays: 180,
        sameSite: 'Strict' as const,
        respectDoNotTrack: false
      };
      
      const mockAutoIdManager = {
        getOrCreateId: vi.fn().mockResolvedValue('webexp_custom123456')
      };
      
      (initializeAutoId as any).mockReturnValue(mockAutoIdManager);
      
      const config: InjectorConfig = {
        envKey: 'test-env',
        flagKey: 'test-flag',
        autoId: autoIdOptions
      };
      
      await init(config);
      
      expect(initializeAutoId).toHaveBeenCalledWith(autoIdOptions);
    });
  });

  describe('init with auto-ID disabled', () => {
    it('should not initialize auto-ID when explicitly disabled', async () => {
      const config: InjectorConfig = {
        envKey: 'test-env',
        flagKey: 'test-flag',
        autoId: { enabled: false }
      };
      
      await init(config);
      
      expect(initializeAutoId).toHaveBeenCalledWith({ enabled: false });
      expect(LD.initialize).toHaveBeenCalledWith(
        'test-env',
        undefined,
        expect.any(Object)
      );
    });

    it('should initialize auto-ID with defaults when autoId option not provided', async () => {
      const mockAutoIdManager = {
        getOrCreateId: vi.fn().mockResolvedValue('webexp_default123456')
      };
      
      (initializeAutoId as any).mockReturnValue(mockAutoIdManager);
      
      const config: InjectorConfig = {
        envKey: 'test-env',
        flagKey: 'test-flag'
      };
      
      await init(config);
      
      expect(initializeAutoId).toHaveBeenCalledWith({});
      expect(mockAutoIdManager.getOrCreateId).toHaveBeenCalled();
    });
  });

  describe('consent and privacy handling', () => {
    it('should handle Do Not Track correctly', async () => {
      const mockAutoIdManager = {
        getOrCreateId: vi.fn().mockResolvedValue(null) // Returns null due to DNT
      };
      
      (initializeAutoId as any).mockReturnValue(mockAutoIdManager);
      
      const config: InjectorConfig = {
        envKey: 'test-env',
        flagKey: 'test-flag',
        autoId: {
          enabled: true,
          respectDoNotTrack: true
        }
      };
      
      await init(config);
      
      expect(mockAutoIdManager.getOrCreateId).toHaveBeenCalled();
      // Should proceed without auto-generated ID
      expect(LD.initialize).toHaveBeenCalledWith(
        'test-env',
        undefined,
        expect.any(Object)
      );
    });

    it('should handle consent requirements', async () => {
      let consentGranted = false;
      const consentCallback = () => consentGranted;
      
      const mockAutoIdManager = {
        getOrCreateId: vi.fn().mockResolvedValue(null) // Returns null due to no consent
      };
      
      (initializeAutoId as any).mockReturnValue(mockAutoIdManager);
      
      const config: InjectorConfig = {
        envKey: 'test-env',
        flagKey: 'test-flag',
        autoId: {
          enabled: true,
          requireConsent: true,
          consentGranted: consentCallback
        }
      };
      
      await init(config);
      
      expect(mockAutoIdManager.getOrCreateId).toHaveBeenCalled();
      
      // Should proceed without auto-generated ID since consent not granted
      expect(LD.initialize).toHaveBeenCalledWith(
        'test-env',
        undefined,
        expect.any(Object)
      );
    });
  });

  describe('error handling', () => {
    it('should handle auto-ID manager errors gracefully', async () => {
      const mockAutoIdManager = {
        getOrCreateId: vi.fn().mockRejectedValue(new Error('Storage error'))
      };
      
      (initializeAutoId as any).mockReturnValue(mockAutoIdManager);
      
      const config: InjectorConfig = {
        envKey: 'test-env',
        flagKey: 'test-flag',
        autoId: { enabled: true }
      };
      
      // Should not throw error
      await expect(init(config)).resolves.toBeDefined();
      
      // Should fall back gracefully
      expect(LD.initialize).toHaveBeenCalledWith(
        'test-env',
        undefined,
        expect.any(Object)
      );
    });
  });

  describe('global auto-ID functions', () => {
    it('should expose getAnonymousId function', () => {
      expect(typeof getAnonymousId).toBe('function');
    });

    it('should expose resetAnonymousId function', () => {
      expect(typeof resetAnonymousId).toBe('function');
      expect(() => resetAnonymousId()).not.toThrow();
    });
  });
});
